import sys,os
import numpy as np
import bpy, mathutils
from math import pi
import random
import time

FolderPath = os.path.dirname(os.path.abspath('DiffCube.py')) #get current directory name
sys.path.append(FolderPath)  #add current directory to import path
from fractalMethods import * 
    
def copyToVertex(parent, vertex, kidname, scaleFactor, rot): #copy the parent to the relevant vertex
    
    kid = dupe(parent,kidname) #create a child object
    prescale = parent.scale[0] #set new object to same scale just in case
    kid.scale = [scaleFactor * prescale, scaleFactor * prescale, scaleFactor * prescale] #scale child
    kid.location = np.asarray(vertex.co) #move child to target vertex
    kid.rotation_quaternion = quatValueExtraction(np.dot(quatMatrix(kid.rotation_quaternion),
                                                                    quatMatrix(mathutils.Euler((rot[0], rot[1], rot[2]),
                                                                                     'XYZ').to_quaternion())))
                                                        #rotate the child, generated by dot product of parent rotation and
                                                        #target rotation
    return kid.name

def DiffFractalGen(startingPoint = [0,0,0],vertRatio=(1/8),scale=0.5,rot=[0,0,0],iterations=1):
    #vertRatio is the number of vertices that are processes per iteration over the total number of verticies in the mesh.
    #In processing, this always rounds down, so .99 on 8 verts processes 7.
    
    bpy.ops.mesh.primitive_cube_add(location=startingPoint) #create initial cube
    parentObj = bpy.context.object #mark the currently selected initial cube as the parent
    parentObj.rotation_mode = "QUATERNION" #set rotation mode to quaternion
    nameParent = parentObj.name 
    
    bpy.ops.object.select_all(action='DESELECT')
    
    for i in range(iterations): 
        vertices = bpy.data.objects[nameParent].data.vertices #get all vertices of the parent
        numVerts = len(vertices) #get the number of vertices
        sampleNum = int(numVerts*vertRatio) #calculate number of vertices to sample, based on the user entered ratio
        if sampleNum<1: #make sure the program is sampling at least 1 vertex
            sampleNum=1

        chosenVerts = random.sample(list(vertices),sampleNum) #choose random vertices, sample prevents repetitions

        
        childList=[]
        firstVert = chosenVerts[0] #choose the first vertex to process
        prevName = copyToVertex(bpy.data.objects[nameParent],firstVert,"FirstChild",scale,rot) #create and transform the child
        
        for vert in chosenVerts[1:]: #iterate through the rest of the vertices
            
            bpy.ops.object.select_all(action='DESELECT')
            nameChild = copyToVertex(bpy.data.objects[nameParent],vert,"CurChild",scale,rot) #create and transform the child
            
            bpy.data.objects[prevName].select = True #select this object and the previous one
            bpy.data.objects[nameChild].select  = True
            bpy.context.scene.objects.active = bpy.data.objects[prevName]
            bpy.ops.object.join() #join selected objects
            
        
        diff(nameParent,prevName) #apply the difference modifier to the parent using the joined children (see fractalMethods.py)
        
        
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[nameParent].select=True #this selection is just to be safe, but i don't think it's necessary
        
        
            
    return parentObj.name

def JoinedFractalGen(startingPoint = [0,0,0],vertRatio=(1/8),scale=0.5,rot=[0,0,0],iterations=1):
    #vertRatio is the number of vertices that are processes per iteration over the total number of verticies in the mesh.
    #In processing, this always rounds down, so .99 on 8 verts processes 7.
    
    bpy.ops.mesh.primitive_cube_add(location=startingPoint) #create initial cube
    parentObj = bpy.context.object #mark the currently selected initial cube as the parent
    parentObj.rotation_mode = "QUATERNION" #set rotation mode to quaternion
    nameParent = parentObj.name 
    
    bpy.ops.object.select_all(action='DESELECT')
    
    for i in range(iterations): 
        vertices = bpy.data.objects[nameParent].data.vertices #get all vertices of the parent
        numVerts = len(vertices) #get the number of vertices
        sampleNum = int(numVerts*vertRatio) #calculate number of vertices to sample, based on the user entered ratio
        if sampleNum<1: #make sure the program is sampling at least 1 vertex
            sampleNum=1

        chosenVerts = random.sample(list(vertices),sampleNum) #choose random vertices, sample prevents repetitions

        
        childList=[]
        firstVert = chosenVerts[0] #choose the first vertex to process
        prevName = copyToVertex(bpy.data.objects[nameParent],firstVert,"FirstChild",scale,rot) #create and transform the child
        
        for vert in chosenVerts[1:]: #iterate through the rest of the vertices
            
            bpy.ops.object.select_all(action='DESELECT')
            nameChild = copyToVertex(bpy.data.objects[nameParent],vert,"CurChild",scale,rot) #create and transform the child
            
            bpy.data.objects[prevName].select = True #select this object and the previous one
            bpy.data.objects[nameChild].select  = True
            bpy.context.scene.objects.active = bpy.data.objects[prevName]
            bpy.ops.object.join() #join selected objects
            
        
        union(nameParent,prevName) #apply the union modifier to the parent using the joined children (see fractalMethods.py)
        
        
        
        bpy.ops.object.select_all(action='DESELECT')
        bpy.data.objects[nameParent].select=True #just to be safe
        
        
            
    return parentObj.name


#### Main Script ##########################

if __name__ == '__main__':
    
    datafile = open(FolderPath+'/CubeData.txt','r') #get the data generated by the main script
    contents=datafile.read()
    datafile.close()
    
    data = contents.split('\n')

    #datalist = [mode,vertRatio,scale,X,Y,Z,iterations]
    
    mode,vertRatio,scale,X,Y,Z,iterations = map(float,data[0].split(',')) #unpack data into variables
    
    Y*=(2*pi/360) #convert degrees to radians
    X*=(2*pi/360)
    Z*=(2*pi/360)

    if int(mode) == 1: #check what mode the user selected
        cubeType='Union'
    else:
        cubeType='Diff'
    
    bpy.ops.wm.open_mainfile(filepath='./BlendFiles/CubeScene.blend') #open the default scene file for rendering
    
    currentTime = time.strftime('%y%m%d-%H%M%S',time.localtime()) #get current time formatted for filenames
   
    bpy.context.scene.render.filepath = './Renders/Cube{}.jpg'.format(cubeType+currentTime) #set render image filepath
    
    if int(mode) == 1: #Generate added fractal if user selected mode 1
        JoinedFractalGen([0,0,0],vertRatio,scale,[X,Y,Z],int(iterations))

    else: #otherwise (if mode 2 is selected) generate subtracted fractal
        DiffFractalGen([0,0,0],vertRatio,scale,[X,Y,Z],int(iterations))

        
    bpy.ops.wm.save_as_mainfile(filepath='./BlendFiles/Cube{}.blend'.format(cubeType+currentTime)) #save blend file
    bpy.ops.render.render(write_still=True) #render image

    

#### FOR TESTING ##########################

# if __name__ == '__main__':
#     bpy.ops.wm.open_mainfile(filepath='TreeScene.blend')
#     bpy.context.scene.render.filepath = './TreeR{}.jpg'.format(time.strftime('%y%m%d-%H%M%S',time.localtime()))
#     treeListA = [pi/6,pi/6,0,0,pi/2,pi/2,2,1,.75]
#     treeListB = [pi/5,pi/5,pi/48,pi/24,pi/10,pi/10,2,1,.75]
#     specialTreeBridge(treeListA,treeListB, iterations=8)
#     bpy.ops.render.render(write_still=True)
        
    